{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\n// this file is a modified version of the code in node core >=14.14.0\n// which is, in turn, a modified version of the rimraf module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\nconst errnos = require('os').constants.errno;\n\nconst {\n  join\n} = require('path');\n\nconst fs = require('../fs.js'); // error codes that mean we need to remove contents\n\n\nconst notEmptyCodes = new Set(['ENOTEMPTY', 'EEXIST', 'EPERM']); // error codes we can retry later\n\nconst retryCodes = new Set(['EBUSY', 'EMFILE', 'ENFILE', 'ENOTEMPTY', 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst defaultOptions = {\n  retryDelay: 100,\n  maxRetries: 0,\n  recursive: false,\n  force: false\n}; // this is drastically simplified, but should be roughly equivalent to what\n// node core throws\n\nclass ERR_FS_EISDIR extends Error {\n  constructor(path) {\n    super();\n    this.info = {\n      code: 'EISDIR',\n      message: 'is a directory',\n      path,\n      syscall: 'rm',\n      errno: errnos.EISDIR\n    };\n    this.name = 'SystemError';\n    this.code = 'ERR_FS_EISDIR';\n    this.errno = errnos.EISDIR;\n    this.syscall = 'rm';\n    this.path = path;\n    this.message = `Path is a directory: ${this.syscall} returned ` + `${this.info.code} (is a directory) ${path}`;\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n}\n\nclass ENOTDIR extends Error {\n  constructor(path) {\n    super();\n    this.name = 'Error';\n    this.code = 'ENOTDIR';\n    this.errno = errnos.ENOTDIR;\n    this.syscall = 'rmdir';\n    this.path = path;\n    this.message = `not a directory, ${this.syscall} '${this.path}'`;\n  }\n\n  toString() {\n    return `${this.name}: ${this.code}: ${this.message}`;\n  }\n\n} // force is passed separately here because we respect it for the first entry\n// into rimraf only, any further calls that are spawned as a result (i.e. to\n// delete content within the target) will ignore ENOENT errors\n\n\nconst rimraf = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path, options, isTop = false) {\n    const force = isTop ? options.force : true;\n    const stat = yield fs.lstat(path).catch(err => {\n      // we only ignore ENOENT if we're forcing this call\n      if (err.code === 'ENOENT' && force) {\n        return;\n      }\n\n      if (isWindows && err.code === 'EPERM') {\n        return fixEPERM(path, options, err, isTop);\n      }\n\n      throw err;\n    }); // no stat object here means either lstat threw an ENOENT, or lstat threw\n    // an EPERM and the fixPERM function took care of things. either way, we're\n    // already done, so return early\n\n    if (!stat) {\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      return rmdir(path, options, null, isTop);\n    }\n\n    return fs.unlink(path).catch(err => {\n      if (err.code === 'ENOENT' && force) {\n        return;\n      }\n\n      if (err.code === 'EISDIR') {\n        return rmdir(path, options, err, isTop);\n      }\n\n      if (err.code === 'EPERM') {\n        // in windows, we handle this through fixEPERM which will also try to\n        // delete things again. everywhere else since deleting the target as a\n        // file didn't work we go ahead and try to delete it as a directory\n        return isWindows ? fixEPERM(path, options, err, isTop) : rmdir(path, options, err, isTop);\n      }\n\n      throw err;\n    });\n  });\n\n  return function rimraf(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst fixEPERM = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (path, options, originalErr, isTop) {\n    const force = isTop ? options.force : true;\n    const targetMissing = yield fs.chmod(path, 0o666).catch(err => {\n      if (err.code === 'ENOENT' && force) {\n        return true;\n      }\n\n      throw originalErr;\n    }); // got an ENOENT above, return now. no file = no problem\n\n    if (targetMissing) {\n      return;\n    } // this function does its own lstat rather than calling rimraf again to avoid\n    // infinite recursion for a repeating EPERM\n\n\n    const stat = yield fs.lstat(path).catch(err => {\n      if (err.code === 'ENOENT' && force) {\n        return;\n      }\n\n      throw originalErr;\n    });\n\n    if (!stat) {\n      return;\n    }\n\n    if (stat.isDirectory()) {\n      return rmdir(path, options, originalErr, isTop);\n    }\n\n    return fs.unlink(path);\n  });\n\n  return function fixEPERM(_x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst rmdir = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (path, options, originalErr, isTop) {\n    if (!options.recursive && isTop) {\n      throw originalErr || new ERR_FS_EISDIR(path);\n    }\n\n    const force = isTop ? options.force : true;\n    return fs.rmdir(path).catch( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator(function* (err) {\n        // in Windows, calling rmdir on a file path will fail with ENOENT rather\n        // than ENOTDIR. to determine if that's what happened, we have to do\n        // another lstat on the path. if the path isn't actually gone, we throw\n        // away the ENOENT and replace it with our own ENOTDIR\n        if (isWindows && err.code === 'ENOENT') {\n          const stillExists = yield fs.lstat(path).then(() => true, () => false);\n\n          if (stillExists) {\n            err = new ENOTDIR(path);\n          }\n        } // not there, not a problem\n\n\n        if (err.code === 'ENOENT' && force) {\n          return;\n        } // we may not have originalErr if lstat tells us our target is a\n        // directory but that changes before we actually remove it, so\n        // only throw it here if it's set\n\n\n        if (originalErr && err.code === 'ENOTDIR') {\n          throw originalErr;\n        } // the directory isn't empty, remove the contents and try again\n\n\n        if (notEmptyCodes.has(err.code)) {\n          const files = yield fs.readdir(path);\n          yield Promise.all(files.map(file => {\n            const target = join(path, file);\n            return rimraf(target, options);\n          }));\n          return fs.rmdir(path);\n        }\n\n        throw err;\n      });\n\n      return function (_x11) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n  });\n\n  return function rmdir(_x7, _x8, _x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst rm = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (path, opts) {\n    const options = { ...defaultOptions,\n      ...opts\n    };\n    let retries = 0;\n\n    const errHandler = /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator(function* (err) {\n        if (retryCodes.has(err.code) && ++retries < options.maxRetries) {\n          const delay = retries * options.retryDelay;\n          yield promiseTimeout(delay);\n          return rimraf(path, options, true).catch(errHandler);\n        }\n\n        throw err;\n      });\n\n      return function errHandler(_x14) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n\n    return rimraf(path, options, true).catch(errHandler);\n  });\n\n  return function rm(_x12, _x13) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nconst promiseTimeout = ms => new Promise(r => setTimeout(r, ms));\n\nmodule.exports = rm;","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@npmcli/fs/lib/rm/polyfill.js"],"names":["errnos","require","constants","errno","join","fs","notEmptyCodes","Set","retryCodes","isWindows","process","platform","defaultOptions","retryDelay","maxRetries","recursive","force","ERR_FS_EISDIR","Error","constructor","path","info","code","message","syscall","EISDIR","name","toString","ENOTDIR","rimraf","options","isTop","stat","lstat","catch","err","fixEPERM","isDirectory","rmdir","unlink","originalErr","targetMissing","chmod","stillExists","then","has","files","readdir","Promise","all","map","file","target","rm","opts","retries","errHandler","delay","promiseTimeout","ms","r","setTimeout","module","exports"],"mappings":"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","sourcesContent":["// this file is a modified version of the code in node core >=14.14.0\n// which is, in turn, a modified version of the rimraf module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\nconst errnos = require('os').constants.errno\nconst { join } = require('path')\nconst fs = require('../fs.js')\n\n// error codes that mean we need to remove contents\nconst notEmptyCodes = new Set([\n  'ENOTEMPTY',\n  'EEXIST',\n  'EPERM',\n])\n\n// error codes we can retry later\nconst retryCodes = new Set([\n  'EBUSY',\n  'EMFILE',\n  'ENFILE',\n  'ENOTEMPTY',\n  'EPERM',\n])\n\nconst isWindows = process.platform === 'win32'\n\nconst defaultOptions = {\n  retryDelay: 100,\n  maxRetries: 0,\n  recursive: false,\n  force: false,\n}\n\n// this is drastically simplified, but should be roughly equivalent to what\n// node core throws\nclass ERR_FS_EISDIR extends Error {\n  constructor (path) {\n    super()\n    this.info = {\n      code: 'EISDIR',\n      message: 'is a directory',\n      path,\n      syscall: 'rm',\n      errno: errnos.EISDIR,\n    }\n    this.name = 'SystemError'\n    this.code = 'ERR_FS_EISDIR'\n    this.errno = errnos.EISDIR\n    this.syscall = 'rm'\n    this.path = path\n    this.message = `Path is a directory: ${this.syscall} returned ` +\n      `${this.info.code} (is a directory) ${path}`\n  }\n\n  toString () {\n    return `${this.name} [${this.code}]: ${this.message}`\n  }\n}\n\nclass ENOTDIR extends Error {\n  constructor (path) {\n    super()\n    this.name = 'Error'\n    this.code = 'ENOTDIR'\n    this.errno = errnos.ENOTDIR\n    this.syscall = 'rmdir'\n    this.path = path\n    this.message = `not a directory, ${this.syscall} '${this.path}'`\n  }\n\n  toString () {\n    return `${this.name}: ${this.code}: ${this.message}`\n  }\n}\n\n// force is passed separately here because we respect it for the first entry\n// into rimraf only, any further calls that are spawned as a result (i.e. to\n// delete content within the target) will ignore ENOENT errors\nconst rimraf = async (path, options, isTop = false) => {\n  const force = isTop ? options.force : true\n  const stat = await fs.lstat(path)\n    .catch((err) => {\n      // we only ignore ENOENT if we're forcing this call\n      if (err.code === 'ENOENT' && force) {\n        return\n      }\n\n      if (isWindows && err.code === 'EPERM') {\n        return fixEPERM(path, options, err, isTop)\n      }\n\n      throw err\n    })\n\n  // no stat object here means either lstat threw an ENOENT, or lstat threw\n  // an EPERM and the fixPERM function took care of things. either way, we're\n  // already done, so return early\n  if (!stat) {\n    return\n  }\n\n  if (stat.isDirectory()) {\n    return rmdir(path, options, null, isTop)\n  }\n\n  return fs.unlink(path)\n    .catch((err) => {\n      if (err.code === 'ENOENT' && force) {\n        return\n      }\n\n      if (err.code === 'EISDIR') {\n        return rmdir(path, options, err, isTop)\n      }\n\n      if (err.code === 'EPERM') {\n        // in windows, we handle this through fixEPERM which will also try to\n        // delete things again. everywhere else since deleting the target as a\n        // file didn't work we go ahead and try to delete it as a directory\n        return isWindows\n          ? fixEPERM(path, options, err, isTop)\n          : rmdir(path, options, err, isTop)\n      }\n\n      throw err\n    })\n}\n\nconst fixEPERM = async (path, options, originalErr, isTop) => {\n  const force = isTop ? options.force : true\n  const targetMissing = await fs.chmod(path, 0o666)\n    .catch((err) => {\n      if (err.code === 'ENOENT' && force) {\n        return true\n      }\n\n      throw originalErr\n    })\n\n  // got an ENOENT above, return now. no file = no problem\n  if (targetMissing) {\n    return\n  }\n\n  // this function does its own lstat rather than calling rimraf again to avoid\n  // infinite recursion for a repeating EPERM\n  const stat = await fs.lstat(path)\n    .catch((err) => {\n      if (err.code === 'ENOENT' && force) {\n        return\n      }\n\n      throw originalErr\n    })\n\n  if (!stat) {\n    return\n  }\n\n  if (stat.isDirectory()) {\n    return rmdir(path, options, originalErr, isTop)\n  }\n\n  return fs.unlink(path)\n}\n\nconst rmdir = async (path, options, originalErr, isTop) => {\n  if (!options.recursive && isTop) {\n    throw originalErr || new ERR_FS_EISDIR(path)\n  }\n  const force = isTop ? options.force : true\n\n  return fs.rmdir(path)\n    .catch(async (err) => {\n      // in Windows, calling rmdir on a file path will fail with ENOENT rather\n      // than ENOTDIR. to determine if that's what happened, we have to do\n      // another lstat on the path. if the path isn't actually gone, we throw\n      // away the ENOENT and replace it with our own ENOTDIR\n      if (isWindows && err.code === 'ENOENT') {\n        const stillExists = await fs.lstat(path).then(() => true, () => false)\n        if (stillExists) {\n          err = new ENOTDIR(path)\n        }\n      }\n\n      // not there, not a problem\n      if (err.code === 'ENOENT' && force) {\n        return\n      }\n\n      // we may not have originalErr if lstat tells us our target is a\n      // directory but that changes before we actually remove it, so\n      // only throw it here if it's set\n      if (originalErr && err.code === 'ENOTDIR') {\n        throw originalErr\n      }\n\n      // the directory isn't empty, remove the contents and try again\n      if (notEmptyCodes.has(err.code)) {\n        const files = await fs.readdir(path)\n        await Promise.all(files.map((file) => {\n          const target = join(path, file)\n          return rimraf(target, options)\n        }))\n        return fs.rmdir(path)\n      }\n\n      throw err\n    })\n}\n\nconst rm = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n  let retries = 0\n\n  const errHandler = async (err) => {\n    if (retryCodes.has(err.code) && ++retries < options.maxRetries) {\n      const delay = retries * options.retryDelay\n      await promiseTimeout(delay)\n      return rimraf(path, options, true).catch(errHandler)\n    }\n\n    throw err\n  }\n\n  return rimraf(path, options, true).catch(errHandler)\n}\n\nconst promiseTimeout = (ms) => new Promise((r) => setTimeout(r, ms))\n\nmodule.exports = rm\n"]},"metadata":{},"sourceType":"script"}