{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  dirname,\n  sep\n} = require('path');\n\nconst fs = require('./fs.js');\n\nconst getOptions = require('./common/get-options.js');\n\nconst owner = require('./common/owner.js');\n\nconst mkdtemp = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (prefix, opts) {\n    const options = getOptions(opts, {\n      copy: ['encoding', 'owner'],\n      wrap: 'encoding'\n    }); // mkdtemp relies on the trailing path separator to indicate if it should\n    // create a directory inside of the prefix. if that's the case then the root\n    // we infer ownership from is the prefix itself, otherwise it's the dirname\n    // /tmp -> /tmpABCDEF, infers from /\n    // /tmp/ -> /tmp/ABCDEF, infers from /tmp\n\n    const root = prefix.endsWith(sep) ? prefix : dirname(prefix);\n    const {\n      uid,\n      gid\n    } = yield owner.validate(root, options.owner);\n    const result = yield fs.mkdtemp(prefix, options);\n    yield owner.update(result, uid, gid);\n    return result;\n  });\n\n  return function mkdtemp(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = mkdtemp;","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@npmcli/fs/lib/mkdtemp.js"],"names":["dirname","sep","require","fs","getOptions","owner","mkdtemp","prefix","opts","options","copy","wrap","root","endsWith","uid","gid","validate","result","update","module","exports"],"mappings":";;AAAA,MAAM;AAAEA,EAAAA,OAAF;AAAWC,EAAAA;AAAX,IAAmBC,OAAO,CAAC,MAAD,CAAhC;;AAEA,MAAMC,EAAE,GAAGD,OAAO,CAAC,SAAD,CAAlB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,yBAAD,CAA1B;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,mBAAD,CAArB;;AAEA,MAAMI,OAAO;AAAA,+BAAG,WAAOC,MAAP,EAAeC,IAAf,EAAwB;AACtC,UAAMC,OAAO,GAAGL,UAAU,CAACI,IAAD,EAAO;AAC/BE,MAAAA,IAAI,EAAE,CAAC,UAAD,EAAa,OAAb,CADyB;AAE/BC,MAAAA,IAAI,EAAE;AAFyB,KAAP,CAA1B,CADsC,CAMtC;AACA;AACA;AACA;AACA;;AACA,UAAMC,IAAI,GAAGL,MAAM,CAACM,QAAP,CAAgBZ,GAAhB,IAAuBM,MAAvB,GAAgCP,OAAO,CAACO,MAAD,CAApD;AACA,UAAM;AAAEO,MAAAA,GAAF;AAAOC,MAAAA;AAAP,cAAqBV,KAAK,CAACW,QAAN,CAAeJ,IAAf,EAAqBH,OAAO,CAACJ,KAA7B,CAA3B;AAEA,UAAMY,MAAM,SAASd,EAAE,CAACG,OAAH,CAAWC,MAAX,EAAmBE,OAAnB,CAArB;AAEA,UAAMJ,KAAK,CAACa,MAAN,CAAaD,MAAb,EAAqBH,GAArB,EAA0BC,GAA1B,CAAN;AAEA,WAAOE,MAAP;AACD,GAnBY;;AAAA,kBAAPX,OAAO;AAAA;AAAA;AAAA,GAAb;;AAqBAa,MAAM,CAACC,OAAP,GAAiBd,OAAjB","sourcesContent":["const { dirname, sep } = require('path')\n\nconst fs = require('./fs.js')\nconst getOptions = require('./common/get-options.js')\nconst owner = require('./common/owner.js')\n\nconst mkdtemp = async (prefix, opts) => {\n  const options = getOptions(opts, {\n    copy: ['encoding', 'owner'],\n    wrap: 'encoding',\n  })\n\n  // mkdtemp relies on the trailing path separator to indicate if it should\n  // create a directory inside of the prefix. if that's the case then the root\n  // we infer ownership from is the prefix itself, otherwise it's the dirname\n  // /tmp -> /tmpABCDEF, infers from /\n  // /tmp/ -> /tmp/ABCDEF, infers from /tmp\n  const root = prefix.endsWith(sep) ? prefix : dirname(prefix)\n  const { uid, gid } = await owner.validate(root, options.owner)\n\n  const result = await fs.mkdtemp(prefix, options)\n\n  await owner.update(result, uid, gid)\n\n  return result\n}\n\nmodule.exports = mkdtemp\n"]},"metadata":{},"sourceType":"script"}