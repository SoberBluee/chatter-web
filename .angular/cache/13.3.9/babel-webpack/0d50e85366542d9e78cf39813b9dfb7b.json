{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (iterable, mapper, {\n    concurrency = Infinity,\n    stopOnError = true\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (typeof mapper !== 'function') {\n        throw new TypeError('Mapper function is required');\n      }\n\n      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n        throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n      }\n\n      const result = [];\n      const errors = [];\n      const iterator = iterable[Symbol.iterator]();\n      let isRejected = false;\n      let isIterableDone = false;\n      let resolvingCount = 0;\n      let currentIndex = 0;\n\n      const next = () => {\n        if (isRejected) {\n          return;\n        }\n\n        const nextItem = iterator.next();\n        const index = currentIndex;\n        currentIndex++;\n\n        if (nextItem.done) {\n          isIterableDone = true;\n\n          if (resolvingCount === 0) {\n            if (!stopOnError && errors.length !== 0) {\n              reject(new AggregateError(errors));\n            } else {\n              resolve(result);\n            }\n          }\n\n          return;\n        }\n\n        resolvingCount++;\n\n        _asyncToGenerator(function* () {\n          try {\n            const element = yield nextItem.value;\n            result[index] = yield mapper(element, index);\n            resolvingCount--;\n            next();\n          } catch (error) {\n            if (stopOnError) {\n              isRejected = true;\n              reject(error);\n            } else {\n              errors.push(error);\n              resolvingCount--;\n              next();\n            }\n          }\n        })();\n      };\n\n      for (let i = 0; i < concurrency; i++) {\n        next();\n\n        if (isIterableDone) {\n          break;\n        }\n      }\n    });\n  });\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/p-map/index.js"],"names":["AggregateError","require","module","exports","iterable","mapper","concurrency","Infinity","stopOnError","Promise","resolve","reject","TypeError","Number","isSafeInteger","result","errors","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","index","done","length","element","value","error","push","i"],"mappings":"AAAA;;;;AACA,MAAMA,cAAc,GAAGC,OAAO,CAAC,iBAAD,CAA9B;;AAEAC,MAAM,CAACC,OAAP;AAAA,+BAAiB,WAChBC,QADgB,EAEhBC,MAFgB,EAGhB;AACCC,IAAAA,WAAW,GAAGC,QADf;AAECC,IAAAA,WAAW,GAAG;AAFf,MAGI,EANY,EAOZ;AACJ,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,UAAI,OAAON,MAAP,KAAkB,UAAtB,EAAkC;AACjC,cAAM,IAAIO,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAED,UAAI,EAAE,CAACC,MAAM,CAACC,aAAP,CAAqBR,WAArB,KAAqCA,WAAW,KAAKC,QAAtD,KAAmED,WAAW,IAAI,CAApF,CAAJ,EAA4F;AAC3F,cAAM,IAAIM,SAAJ,CAAe,kFAAiFN,WAAY,OAAM,OAAOA,WAAY,GAArI,CAAN;AACA;;AAED,YAAMS,MAAM,GAAG,EAAf;AACA,YAAMC,MAAM,GAAG,EAAf;AACA,YAAMC,QAAQ,GAAGb,QAAQ,CAACc,MAAM,CAACD,QAAR,CAAR,EAAjB;AACA,UAAIE,UAAU,GAAG,KAAjB;AACA,UAAIC,cAAc,GAAG,KAArB;AACA,UAAIC,cAAc,GAAG,CAArB;AACA,UAAIC,YAAY,GAAG,CAAnB;;AAEA,YAAMC,IAAI,GAAG,MAAM;AAClB,YAAIJ,UAAJ,EAAgB;AACf;AACA;;AAED,cAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAT,EAAjB;AACA,cAAME,KAAK,GAAGH,YAAd;AACAA,QAAAA,YAAY;;AAEZ,YAAIE,QAAQ,CAACE,IAAb,EAAmB;AAClBN,UAAAA,cAAc,GAAG,IAAjB;;AAEA,cAAIC,cAAc,KAAK,CAAvB,EAA0B;AACzB,gBAAI,CAACb,WAAD,IAAgBQ,MAAM,CAACW,MAAP,KAAkB,CAAtC,EAAyC;AACxChB,cAAAA,MAAM,CAAC,IAAIX,cAAJ,CAAmBgB,MAAnB,CAAD,CAAN;AACA,aAFD,MAEO;AACNN,cAAAA,OAAO,CAACK,MAAD,CAAP;AACA;AACD;;AAED;AACA;;AAEDM,QAAAA,cAAc;;AAEd,0BAAC,aAAY;AACZ,cAAI;AACH,kBAAMO,OAAO,SAASJ,QAAQ,CAACK,KAA/B;AACAd,YAAAA,MAAM,CAACU,KAAD,CAAN,SAAsBpB,MAAM,CAACuB,OAAD,EAAUH,KAAV,CAA5B;AACAJ,YAAAA,cAAc;AACdE,YAAAA,IAAI;AACJ,WALD,CAKE,OAAOO,KAAP,EAAc;AACf,gBAAItB,WAAJ,EAAiB;AAChBW,cAAAA,UAAU,GAAG,IAAb;AACAR,cAAAA,MAAM,CAACmB,KAAD,CAAN;AACA,aAHD,MAGO;AACNd,cAAAA,MAAM,CAACe,IAAP,CAAYD,KAAZ;AACAT,cAAAA,cAAc;AACdE,cAAAA,IAAI;AACJ;AACD;AACD,SAhBD;AAiBA,OA1CD;;AA4CA,WAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1B,WAApB,EAAiC0B,CAAC,EAAlC,EAAsC;AACrCT,QAAAA,IAAI;;AAEJ,YAAIH,cAAJ,EAAoB;AACnB;AACA;AACD;AACD,KApEM,CAAP;AAqEA,GA7ED;;AAAA;AAAA;AAAA;AAAA","sourcesContent":["'use strict';\nconst AggregateError = require('aggregate-error');\n\nmodule.exports = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new AggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}