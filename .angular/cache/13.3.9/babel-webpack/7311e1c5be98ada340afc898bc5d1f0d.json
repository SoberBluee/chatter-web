{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  dirname\n} = require('path');\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js');\n\nconst fs = require('../fs.js');\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false\n};\n\nconst mkdir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path, opts) {\n    const options = { ...defaultOptions,\n      ...opts\n    }; // if we're not in recursive mode, just call the real mkdir with the path and\n    // the mode option only\n\n    if (!options.recursive) {\n      return fs.mkdir(path, options.mode);\n    }\n\n    const makeDirectory = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (dir, mode) {\n        // we can't use dirname directly since these functions support URL\n        // objects with the file: protocol as the path input, so first we get a\n        // string path, then we can call dirname on that\n        const parent = dir != null && dir.href && dir.origin ? dirname(fileURLToPath(dir)) : dirname(dir); // if the parent is the dir itself, try to create it. anything but EISDIR\n        // should be rethrown\n\n        if (parent === dir) {\n          try {\n            yield fs.mkdir(dir, opts);\n          } catch (err) {\n            if (err.code !== 'EISDIR') {\n              throw err;\n            }\n          }\n\n          return undefined;\n        }\n\n        try {\n          yield fs.mkdir(dir, mode);\n          return dir;\n        } catch (err) {\n          // ENOENT means the parent wasn't there, so create that\n          if (err.code === 'ENOENT') {\n            const made = yield makeDirectory(parent, mode);\n            yield makeDirectory(dir, mode); // return the shallowest path we created, i.e. the result of creating\n            // the parent\n\n            return made;\n          } // an EEXIST means there's already something there\n          // an EROFS means we have a read-only filesystem and can't create a dir\n          // any other error is fatal and we should give up now\n\n\n          if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n            throw err;\n          } // stat the directory, if the result is a directory, then we successfully\n          // created this one so return its path. otherwise, we reject with the\n          // original error by ignoring the error in the catch\n\n\n          try {\n            const stat = yield fs.stat(dir);\n\n            if (stat.isDirectory()) {\n              // if it already existed, we didn't create anything so return\n              // undefined\n              return undefined;\n            }\n          } catch (_) {} // if the thing that's there isn't a directory, then just re-throw\n\n\n          throw err;\n        }\n      });\n\n      return function makeDirectory(_x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    return makeDirectory(path, options.mode);\n  });\n\n  return function mkdir(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = mkdir;","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@npmcli/fs/lib/mkdir/polyfill.js"],"names":["dirname","require","fileURLToPath","fs","defaultOptions","mode","recursive","mkdir","path","opts","options","makeDirectory","dir","parent","href","origin","err","code","undefined","made","stat","isDirectory","_","module","exports"],"mappings":";;AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AAEA,MAAMC,aAAa,GAAGD,OAAO,CAAC,qCAAD,CAA7B;;AACA,MAAME,EAAE,GAAGF,OAAO,CAAC,UAAD,CAAlB;;AAEA,MAAMG,cAAc,GAAG;AACrBC,EAAAA,IAAI,EAAE,KADe;AAErBC,EAAAA,SAAS,EAAE;AAFU,CAAvB;;AAKA,MAAMC,KAAK;AAAA,+BAAG,WAAOC,IAAP,EAAaC,IAAb,EAAsB;AAClC,UAAMC,OAAO,GAAG,EAAE,GAAGN,cAAL;AAAqB,SAAGK;AAAxB,KAAhB,CADkC,CAGlC;AACA;;AACA,QAAI,CAACC,OAAO,CAACJ,SAAb,EAAwB;AACtB,aAAOH,EAAE,CAACI,KAAH,CAASC,IAAT,EAAeE,OAAO,CAACL,IAAvB,CAAP;AACD;;AAED,UAAMM,aAAa;AAAA,oCAAG,WAAOC,GAAP,EAAYP,IAAZ,EAAqB;AACzC;AACA;AACA;AACA,cAAMQ,MAAM,GAAGD,GAAG,IAAI,IAAP,IAAeA,GAAG,CAACE,IAAnB,IAA2BF,GAAG,CAACG,MAA/B,GACXf,OAAO,CAACE,aAAa,CAACU,GAAD,CAAd,CADI,GAEXZ,OAAO,CAACY,GAAD,CAFX,CAJyC,CAQzC;AACA;;AACA,YAAIC,MAAM,KAAKD,GAAf,EAAoB;AAClB,cAAI;AACF,kBAAMT,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcH,IAAd,CAAN;AACD,WAFD,CAEE,OAAOO,GAAP,EAAY;AACZ,gBAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;AACzB,oBAAMD,GAAN;AACD;AACF;;AACD,iBAAOE,SAAP;AACD;;AAED,YAAI;AACF,gBAAMf,EAAE,CAACI,KAAH,CAASK,GAAT,EAAcP,IAAd,CAAN;AACA,iBAAOO,GAAP;AACD,SAHD,CAGE,OAAOI,GAAP,EAAY;AACZ;AACA,cAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;AACzB,kBAAME,IAAI,SAASR,aAAa,CAACE,MAAD,EAASR,IAAT,CAAhC;AACA,kBAAMM,aAAa,CAACC,GAAD,EAAMP,IAAN,CAAnB,CAFyB,CAGzB;AACA;;AACA,mBAAOc,IAAP;AACD,WARW,CAUZ;AACA;AACA;;;AACA,cAAIH,GAAG,CAACC,IAAJ,KAAa,QAAb,IAAyBD,GAAG,CAACC,IAAJ,KAAa,OAA1C,EAAmD;AACjD,kBAAMD,GAAN;AACD,WAfW,CAiBZ;AACA;AACA;;;AACA,cAAI;AACF,kBAAMI,IAAI,SAASjB,EAAE,CAACiB,IAAH,CAAQR,GAAR,CAAnB;;AACA,gBAAIQ,IAAI,CAACC,WAAL,EAAJ,EAAwB;AACtB;AACA;AACA,qBAAOH,SAAP;AACD;AACF,WAPD,CAOE,OAAOI,CAAP,EAAU,CAAE,CA3BF,CA6BZ;;;AACA,gBAAMN,GAAN;AACD;AACF,OAxDkB;;AAAA,sBAAbL,aAAa;AAAA;AAAA;AAAA,OAAnB;;AA0DA,WAAOA,aAAa,CAACH,IAAD,EAAOE,OAAO,CAACL,IAAf,CAApB;AACD,GApEU;;AAAA,kBAALE,KAAK;AAAA;AAAA;AAAA,GAAX;;AAsEAgB,MAAM,CAACC,OAAP,GAAiBjB,KAAjB","sourcesContent":["const { dirname } = require('path')\n\nconst fileURLToPath = require('../common/file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\nconst defaultOptions = {\n  mode: 0o777,\n  recursive: false,\n}\n\nconst mkdir = async (path, opts) => {\n  const options = { ...defaultOptions, ...opts }\n\n  // if we're not in recursive mode, just call the real mkdir with the path and\n  // the mode option only\n  if (!options.recursive) {\n    return fs.mkdir(path, options.mode)\n  }\n\n  const makeDirectory = async (dir, mode) => {\n    // we can't use dirname directly since these functions support URL\n    // objects with the file: protocol as the path input, so first we get a\n    // string path, then we can call dirname on that\n    const parent = dir != null && dir.href && dir.origin\n      ? dirname(fileURLToPath(dir))\n      : dirname(dir)\n\n    // if the parent is the dir itself, try to create it. anything but EISDIR\n    // should be rethrown\n    if (parent === dir) {\n      try {\n        await fs.mkdir(dir, opts)\n      } catch (err) {\n        if (err.code !== 'EISDIR') {\n          throw err\n        }\n      }\n      return undefined\n    }\n\n    try {\n      await fs.mkdir(dir, mode)\n      return dir\n    } catch (err) {\n      // ENOENT means the parent wasn't there, so create that\n      if (err.code === 'ENOENT') {\n        const made = await makeDirectory(parent, mode)\n        await makeDirectory(dir, mode)\n        // return the shallowest path we created, i.e. the result of creating\n        // the parent\n        return made\n      }\n\n      // an EEXIST means there's already something there\n      // an EROFS means we have a read-only filesystem and can't create a dir\n      // any other error is fatal and we should give up now\n      if (err.code !== 'EEXIST' && err.code !== 'EROFS') {\n        throw err\n      }\n\n      // stat the directory, if the result is a directory, then we successfully\n      // created this one so return its path. otherwise, we reject with the\n      // original error by ignoring the error in the catch\n      try {\n        const stat = await fs.stat(dir)\n        if (stat.isDirectory()) {\n          // if it already existed, we didn't create anything so return\n          // undefined\n          return undefined\n        }\n      } catch (_) {}\n\n      // if the thing that's there isn't a directory, then just re-throw\n      throw err\n    }\n  }\n\n  return makeDirectory(path, options.mode)\n}\n\nmodule.exports = mkdir\n"]},"metadata":{},"sourceType":"script"}