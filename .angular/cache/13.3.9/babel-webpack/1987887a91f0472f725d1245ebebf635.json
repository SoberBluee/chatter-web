{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  Request,\n  Response\n} = require('minipass-fetch');\n\nconst Minipass = require('minipass');\n\nconst MinipassCollect = require('minipass-collect');\n\nconst MinipassFlush = require('minipass-flush');\n\nconst MinipassPipeline = require('minipass-pipeline');\n\nconst cacache = require('cacache');\n\nconst url = require('url');\n\nconst CachePolicy = require('./policy.js');\n\nconst cacheKey = require('./key.js');\n\nconst remote = require('../remote.js');\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop); // maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\n\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\n\nconst KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control']; // allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\n\nconst KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'location', 'pragma', 'vary']; // return an object containing all metadata to be written to the index\n\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {}\n  }; // only save the status if it's not a 200 or 304\n\n  if (response.status !== 200 && response.status !== 304) metadata.status = response.status;\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);\n  } // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n\n\n  const host = request.headers.get('host');\n  const parsedUrl = new url.URL(request.url);\n  if (host && parsedUrl.host !== host) metadata.reqHeaders.host = host; // if the response has a vary header, make sure\n  // we store the relevant request headers too\n\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary'); // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n\n      for (const name of varyHeaders) {\n        // explicitly ignore accept-encoding here\n        if (name !== 'accept-encoding' && request.headers.has(name)) metadata.reqHeaders[name] = request.headers.get(name);\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) metadata.resHeaders[name] = response.headers.get(name);\n  } // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n\n\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding');\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding');\n  }\n\n  return metadata;\n}; // symbols used to hide objects that may be lazily evaluated in a getter\n\n\nconst _request = Symbol('request');\n\nconst _response = Symbol('response');\n\nconst _policy = Symbol('policy');\n\nclass CacheEntry {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry; // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else this.key = cacheKey(request);\n\n    this.options = options; // these properties are behind getters that lazily evaluate\n\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  } // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n\n\n  static find(request, options) {\n    return _asyncToGenerator(function* () {\n      try {\n        // compacts the index and returns an array of unique entries\n        var matches = yield cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n          const entryA = new CacheEntry({\n            entry: A,\n            options\n          });\n          const entryB = new CacheEntry({\n            entry: B,\n            options\n          });\n          return entryA.policy.satisfies(entryB.request);\n        }, {\n          validateEntry: entry => {\n            // if an integrity is null, it needs to have a status specified\n            if (entry.integrity === null) return !!(entry.metadata && entry.metadata.status);\n            return true;\n          }\n        });\n      } catch (err) {\n        // if the compact request fails, ignore the error and return\n        return;\n      } // a cache mode of 'reload' means to behave as though we have no cache\n      // on the way to the network. return undefined to allow cacheFetch to\n      // create a brand new request no matter what.\n\n\n      if (options.cache === 'reload') return; // find the specific entry that satisfies the request\n\n      let match;\n\n      for (const entry of matches) {\n        const _entry = new CacheEntry({\n          entry,\n          options\n        });\n\n        if (_entry.policy.satisfies(request)) {\n          match = _entry;\n          break;\n        }\n      }\n\n      return match;\n    })();\n  } // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n\n\n  static invalidate(request, options) {\n    return _asyncToGenerator(function* () {\n      const key = cacheKey(request);\n\n      try {\n        yield cacache.rm.entry(options.cachePath, key, {\n          removeFully: true\n        });\n      } catch (err) {// ignore errors\n      }\n    })();\n  }\n\n  get request() {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders\n      });\n    }\n\n    return this[_request];\n  }\n\n  get response() {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: { ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size\n        }\n      });\n    }\n\n    return this[_response];\n  }\n\n  get policy() {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options\n      });\n    }\n\n    return this[_policy];\n  } // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n\n\n  store(status) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // if we got a status other than 200, 301, or 308,\n      // or the CachePolicy forbid storage, append the\n      // cache status header and return it untouched\n      if (_this.request.method !== 'GET' || ![200, 301, 308].includes(_this.response.status) || !_this.policy.storable()) {\n        _this.response.headers.set('x-local-cache-status', 'skip');\n\n        return _this.response;\n      }\n\n      const size = _this.response.headers.get('content-length');\n\n      const fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE;\n      const shouldBuffer = _this.options.memoize !== false && fitsInMemory;\n      const cacheOpts = {\n        algorithms: _this.options.algorithms,\n        metadata: getMetadata(_this.request, _this.response, _this.options),\n        size,\n        memoize: fitsInMemory && _this.options.memoize\n      };\n      let body = null; // we only set a body if the status is a 200, redirects are\n      // stored as metadata only\n\n      if (_this.response.status === 200) {\n        let cacheWriteResolve, cacheWriteReject;\n        const cacheWritePromise = new Promise((resolve, reject) => {\n          cacheWriteResolve = resolve;\n          cacheWriteReject = reject;\n        });\n        body = new MinipassPipeline(new MinipassFlush({\n          flush() {\n            return cacheWritePromise;\n          }\n\n        }));\n        let abortStream, onResume;\n\n        if (shouldBuffer) {\n          // if the result fits in memory, use a collect stream to gather\n          // the response and write it to cacache while also passing it through\n          // to the user\n          onResume = () => {\n            const collector = new MinipassCollect.PassThrough();\n            abortStream = collector;\n            collector.on('collect', data => {\n              // TODO if the cache write fails, log a warning but return the response anyway\n              cacache.put(_this.options.cachePath, _this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject);\n            });\n            body.unshift(collector);\n            body.unshift(_this.response.body);\n          };\n        } else {\n          // if it does not fit in memory, create a tee stream and use\n          // that to pipe to both the cache and the user simultaneously\n          onResume = () => {\n            const tee = new Minipass();\n            const cacheStream = cacache.put.stream(_this.options.cachePath, _this.key, cacheOpts);\n            abortStream = cacheStream;\n            tee.pipe(cacheStream); // TODO if the cache write fails, log a warning but return the response anyway\n\n            cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n            body.unshift(tee);\n            body.unshift(_this.response.body);\n          };\n        }\n\n        body.once('resume', onResume);\n        body.once('end', () => body.removeListener('resume', onResume));\n\n        _this.response.body.on('error', err => {\n          // the abortStream will either be a MinipassCollect if we buffer\n          // or a cacache write stream, either way be sure to listen for\n          // errors from the actual response and avoid writing data that we\n          // know to be invalid to the cache\n          abortStream.destroy(err);\n        });\n      } else yield cacache.index.insert(_this.options.cachePath, _this.key, null, cacheOpts); // note: we do not set the x-local-cache-hash header because we do not know\n      // the hash value until after the write to the cache completes, which doesn't\n      // happen until after the response has been sent and it's too late to write\n      // the header anyway\n\n\n      _this.response.headers.set('x-local-cache', encodeURIComponent(_this.options.cachePath));\n\n      _this.response.headers.set('x-local-cache-key', encodeURIComponent(_this.key));\n\n      _this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n\n      _this.response.headers.set('x-local-cache-status', status);\n\n      _this.response.headers.set('x-local-cache-time', new Date().toISOString());\n\n      const newResponse = new Response(body, {\n        url: _this.response.url,\n        status: _this.response.status,\n        headers: _this.response.headers,\n        counter: _this.options.counter\n      });\n      return newResponse;\n    })();\n  } // use the cached data to create a response and return it\n\n\n  respond(method, options, status) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let response;\n      const size = Number(_this2.response.headers.get('content-length'));\n      const fitsInMemory = !!size && size < MAX_MEM_SIZE;\n      const shouldBuffer = _this2.options.memoize !== false && fitsInMemory;\n\n      if (method === 'HEAD' || [301, 308].includes(_this2.response.status)) {\n        // if the request is a HEAD, or the response is a redirect,\n        // then the metadata in the entry already includes everything\n        // we need to build a response\n        response = _this2.response;\n      } else {\n        // we're responding with a full cached response, so create a body\n        // that reads from cacache and attach it to a new Response\n        const body = new Minipass();\n\n        const removeOnResume = () => body.removeListener('resume', onResume);\n\n        let onResume;\n\n        if (shouldBuffer) {\n          onResume = /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* () {\n              removeOnResume();\n\n              try {\n                const content = yield cacache.get.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n                  memoize: _this2.options.memoize\n                });\n                body.end(content);\n              } catch (err) {\n                if (err.code === 'EINTEGRITY') yield cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                  memoize: _this2.options.memoize\n                });\n                if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') yield CacheEntry.invalidate(_this2.request, _this2.options);\n                body.emit('error', err);\n              }\n            });\n\n            return function onResume() {\n              return _ref.apply(this, arguments);\n            };\n          }();\n        } else {\n          onResume = () => {\n            const cacheStream = cacache.get.stream.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n              memoize: _this2.options.memoize\n            });\n            cacheStream.on('error', /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator(function* (err) {\n                cacheStream.pause();\n                if (err.code === 'EINTEGRITY') yield cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                  memoize: _this2.options.memoize\n                });\n                if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') yield CacheEntry.invalidate(_this2.request, _this2.options);\n                body.emit('error', err);\n                cacheStream.resume();\n              });\n\n              return function (_x) {\n                return _ref2.apply(this, arguments);\n              };\n            }());\n            cacheStream.pipe(body);\n          };\n        }\n\n        body.once('resume', onResume);\n        body.once('end', removeOnResume);\n        response = new Response(body, {\n          url: _this2.entry.metadata.url,\n          counter: options.counter,\n          status: 200,\n          headers: { ..._this2.policy.responseHeaders()\n          }\n        });\n      }\n\n      response.headers.set('x-local-cache', encodeURIComponent(_this2.options.cachePath));\n      response.headers.set('x-local-cache-hash', encodeURIComponent(_this2.entry.integrity));\n      response.headers.set('x-local-cache-key', encodeURIComponent(_this2.key));\n      response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream');\n      response.headers.set('x-local-cache-status', status);\n      response.headers.set('x-local-cache-time', new Date(_this2.entry.metadata.time).toUTCString());\n      return response;\n    })();\n  } // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n\n\n  revalidate(request, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const revalidateRequest = new Request(request, {\n        headers: _this3.policy.revalidationHeaders(request)\n      });\n\n      try {\n        // NOTE: be sure to remove the headers property from the\n        // user supplied options, since we have already defined\n        // them on the new request object. if they're still in the\n        // options then those will overwrite the ones from the policy\n        var response = yield remote(revalidateRequest, { ...options,\n          headers: undefined\n        });\n      } catch (err) {\n        // if the network fetch fails, return the stale\n        // cached response unless it has a cache-control\n        // of 'must-revalidate'\n        if (!_this3.policy.mustRevalidate) return _this3.respond(request.method, options, 'stale');\n        throw err;\n      }\n\n      if (_this3.policy.revalidated(revalidateRequest, response)) {\n        // we got a 304, write a new index to the cache and respond from cache\n        const metadata = getMetadata(request, response, options); // 304 responses do not include headers that are specific to the response data\n        // since they do not include a body, so we copy values for headers that were\n        // in the old cache entry to the new one, if the new metadata does not already\n        // include that header\n\n        for (const name of KEEP_RESPONSE_HEADERS) {\n          if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(_this3.entry.metadata.resHeaders, name)) metadata.resHeaders[name] = _this3.entry.metadata.resHeaders[name];\n        }\n\n        try {\n          yield cacache.index.insert(options.cachePath, _this3.key, _this3.entry.integrity, {\n            size: _this3.entry.size,\n            metadata\n          });\n        } catch (err) {// if updating the cache index fails, we ignore it and\n          // respond anyway\n        }\n\n        return _this3.respond(request.method, options, 'revalidated');\n      } // if we got a modified response, create a new entry based on it\n\n\n      const newEntry = new CacheEntry({\n        request,\n        response,\n        options\n      }); // respond with the new entry while writing it to the cache\n\n      return newEntry.store('updated');\n    })();\n  }\n\n}\n\nmodule.exports = CacheEntry;","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/make-fetch-happen/lib/cache/entry.js"],"names":["Request","Response","require","Minipass","MinipassCollect","MinipassFlush","MinipassPipeline","cacache","url","CachePolicy","cacheKey","remote","hasOwnProperty","obj","prop","Object","prototype","call","MAX_MEM_SIZE","KEEP_REQUEST_HEADERS","KEEP_RESPONSE_HEADERS","getMetadata","request","response","options","metadata","time","Date","now","reqHeaders","resHeaders","status","name","headers","has","get","host","parsedUrl","URL","vary","varyHeaders","trim","toLowerCase","split","compress","_request","Symbol","_response","_policy","CacheEntry","constructor","entry","key","find","matches","index","compact","cachePath","A","B","entryA","entryB","policy","satisfies","validateEntry","integrity","err","cache","match","_entry","invalidate","rm","removeFully","method","counter","size","store","includes","storable","set","fitsInMemory","Number","shouldBuffer","memoize","cacheOpts","algorithms","body","cacheWriteResolve","cacheWriteReject","cacheWritePromise","Promise","resolve","reject","flush","abortStream","onResume","collector","PassThrough","on","data","put","then","unshift","tee","cacheStream","stream","pipe","promise","once","removeListener","destroy","insert","encodeURIComponent","toISOString","newResponse","respond","removeOnResume","content","byDigest","end","code","emit","pause","resume","responseHeaders","toUTCString","revalidate","revalidateRequest","revalidationHeaders","undefined","mustRevalidate","revalidated","newEntry","module","exports"],"mappings":"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","sourcesContent":["const { Request, Response } = require('minipass-fetch')\nconst Minipass = require('minipass')\nconst MinipassCollect = require('minipass-collect')\nconst MinipassFlush = require('minipass-flush')\nconst MinipassPipeline = require('minipass-pipeline')\nconst cacache = require('cacache')\nconst url = require('url')\n\nconst CachePolicy = require('./policy.js')\nconst cacheKey = require('./key.js')\nconst remote = require('../remote.js')\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n\n// maximum amount of data we will buffer into memory\n// if we'll exceed this, we switch to streaming\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\n// allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\nconst KEEP_REQUEST_HEADERS = [\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept',\n  'cache-control',\n]\n\n// allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\nconst KEEP_RESPONSE_HEADERS = [\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-type',\n  'date',\n  'etag',\n  'expires',\n  'last-modified',\n  'location',\n  'pragma',\n  'vary',\n]\n\n// return an object containing all metadata to be written to the index\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n  }\n\n  // only save the status if it's not a 200 or 304\n  if (response.status !== 200 && response.status !== 304)\n    metadata.status = response.status\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name))\n      metadata.reqHeaders[name] = request.headers.get(name)\n  }\n\n  // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n  const host = request.headers.get('host')\n  const parsedUrl = new url.URL(request.url)\n  if (host && parsedUrl.host !== host)\n    metadata.reqHeaders.host = host\n\n  // if the response has a vary header, make sure\n  // we store the relevant request headers too\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary')\n    // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/)\n      for (const name of varyHeaders) {\n        // explicitly ignore accept-encoding here\n        if (name !== 'accept-encoding' && request.headers.has(name))\n          metadata.reqHeaders[name] = request.headers.get(name)\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name))\n      metadata.resHeaders[name] = response.headers.get(name)\n  }\n\n  // we only store accept-encoding and content-encoding if the user\n  // has disabled automatic compression and decompression in minipass-fetch\n  // since if it's enabled (the default) then the content will have\n  // already been decompressed making the header a lie\n  if (options.compress === false) {\n    metadata.reqHeaders['accept-encoding'] = request.headers.get('accept-encoding')\n    metadata.resHeaders['content-encoding'] = response.headers.get('content-encoding')\n  }\n\n  return metadata\n}\n\n// symbols used to hide objects that may be lazily evaluated in a getter\nconst _request = Symbol('request')\nconst _response = Symbol('response')\nconst _policy = Symbol('policy')\n\nclass CacheEntry {\n  constructor ({ entry, request, response, options }) {\n    if (entry) {\n      this.key = entry.key\n      this.entry = entry\n      // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time\n    } else\n      this.key = cacheKey(request)\n\n    this.options = options\n\n    // these properties are behind getters that lazily evaluate\n    this[_request] = request\n    this[_response] = response\n    this[_policy] = null\n  }\n\n  // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n  static async find (request, options) {\n    try {\n      // compacts the index and returns an array of unique entries\n      var matches = await cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n        const entryA = new CacheEntry({ entry: A, options })\n        const entryB = new CacheEntry({ entry: B, options })\n        return entryA.policy.satisfies(entryB.request)\n      }, {\n        validateEntry: (entry) => {\n          // if an integrity is null, it needs to have a status specified\n          if (entry.integrity === null)\n            return !!(entry.metadata && entry.metadata.status)\n\n          return true\n        },\n      })\n    } catch (err) {\n      // if the compact request fails, ignore the error and return\n      return\n    }\n\n    // a cache mode of 'reload' means to behave as though we have no cache\n    // on the way to the network. return undefined to allow cacheFetch to\n    // create a brand new request no matter what.\n    if (options.cache === 'reload')\n      return\n\n    // find the specific entry that satisfies the request\n    let match\n    for (const entry of matches) {\n      const _entry = new CacheEntry({\n        entry,\n        options,\n      })\n\n      if (_entry.policy.satisfies(request)) {\n        match = _entry\n        break\n      }\n    }\n\n    return match\n  }\n\n  // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n  static async invalidate (request, options) {\n    const key = cacheKey(request)\n    try {\n      await cacache.rm.entry(options.cachePath, key, { removeFully: true })\n    } catch (err) {\n      // ignore errors\n    }\n  }\n\n  get request () {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n      })\n    }\n\n    return this[_request]\n  }\n\n  get response () {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: {\n          ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size,\n        },\n      })\n    }\n\n    return this[_response]\n  }\n\n  get policy () {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options,\n      })\n    }\n\n    return this[_policy]\n  }\n\n  // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n  async store (status) {\n    // if we got a status other than 200, 301, or 308,\n    // or the CachePolicy forbid storage, append the\n    // cache status header and return it untouched\n    if (this.request.method !== 'GET' || ![200, 301, 308].includes(this.response.status) || !this.policy.storable()) {\n      this.response.headers.set('x-local-cache-status', 'skip')\n      return this.response\n    }\n\n    const size = this.response.headers.get('content-length')\n    const fitsInMemory = !!size && Number(size) < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    const cacheOpts = {\n      algorithms: this.options.algorithms,\n      metadata: getMetadata(this.request, this.response, this.options),\n      size,\n      memoize: fitsInMemory && this.options.memoize,\n    }\n\n    let body = null\n    // we only set a body if the status is a 200, redirects are\n    // stored as metadata only\n    if (this.response.status === 200) {\n      let cacheWriteResolve, cacheWriteReject\n      const cacheWritePromise = new Promise((resolve, reject) => {\n        cacheWriteResolve = resolve\n        cacheWriteReject = reject\n      })\n\n      body = new MinipassPipeline(new MinipassFlush({\n        flush () {\n          return cacheWritePromise\n        },\n      }))\n\n      let abortStream, onResume\n      if (shouldBuffer) {\n        // if the result fits in memory, use a collect stream to gather\n        // the response and write it to cacache while also passing it through\n        // to the user\n        onResume = () => {\n          const collector = new MinipassCollect.PassThrough()\n          abortStream = collector\n          collector.on('collect', (data) => {\n            // TODO if the cache write fails, log a warning but return the response anyway\n            cacache.put(this.options.cachePath, this.key, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject)\n          })\n          body.unshift(collector)\n          body.unshift(this.response.body)\n        }\n      } else {\n        // if it does not fit in memory, create a tee stream and use\n        // that to pipe to both the cache and the user simultaneously\n        onResume = () => {\n          const tee = new Minipass()\n          const cacheStream = cacache.put.stream(this.options.cachePath, this.key, cacheOpts)\n          abortStream = cacheStream\n          tee.pipe(cacheStream)\n          // TODO if the cache write fails, log a warning but return the response anyway\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n          body.unshift(tee)\n          body.unshift(this.response.body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', () => body.removeListener('resume', onResume))\n      this.response.body.on('error', (err) => {\n        // the abortStream will either be a MinipassCollect if we buffer\n        // or a cacache write stream, either way be sure to listen for\n        // errors from the actual response and avoid writing data that we\n        // know to be invalid to the cache\n        abortStream.destroy(err)\n      })\n    } else\n      await cacache.index.insert(this.options.cachePath, this.key, null, cacheOpts)\n\n    // note: we do not set the x-local-cache-hash header because we do not know\n    // the hash value until after the write to the cache completes, which doesn't\n    // happen until after the response has been sent and it's too late to write\n    // the header anyway\n    this.response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    this.response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    this.response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    this.response.headers.set('x-local-cache-status', status)\n    this.response.headers.set('x-local-cache-time', new Date().toISOString())\n    const newResponse = new Response(body, {\n      url: this.response.url,\n      status: this.response.status,\n      headers: this.response.headers,\n      counter: this.options.counter,\n    })\n    return newResponse\n  }\n\n  // use the cached data to create a response and return it\n  async respond (method, options, status) {\n    let response\n    const size = Number(this.response.headers.get('content-length'))\n    const fitsInMemory = !!size && size < MAX_MEM_SIZE\n    const shouldBuffer = this.options.memoize !== false && fitsInMemory\n    if (method === 'HEAD' || [301, 308].includes(this.response.status)) {\n      // if the request is a HEAD, or the response is a redirect,\n      // then the metadata in the entry already includes everything\n      // we need to build a response\n      response = this.response\n    } else {\n      // we're responding with a full cached response, so create a body\n      // that reads from cacache and attach it to a new Response\n      const body = new Minipass()\n      const removeOnResume = () => body.removeListener('resume', onResume)\n      let onResume\n      if (shouldBuffer) {\n        onResume = async () => {\n          removeOnResume()\n          try {\n            const content = await cacache.get.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            body.end(content)\n          } catch (err) {\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n          }\n        }\n      } else {\n        onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n          cacheStream.on('error', async (err) => {\n            cacheStream.pause()\n            if (err.code === 'EINTEGRITY')\n              await cacache.rm.content(this.options.cachePath, this.entry.integrity, { memoize: this.options.memoize })\n            if (err.code === 'ENOENT' || err.code === 'EINTEGRITY')\n              await CacheEntry.invalidate(this.request, this.options)\n            body.emit('error', err)\n            cacheStream.resume()\n          })\n          cacheStream.pipe(body)\n        }\n      }\n\n      body.once('resume', onResume)\n      body.once('end', removeOnResume)\n      response = new Response(body, {\n        url: this.entry.metadata.url,\n        counter: options.counter,\n        status: 200,\n        headers: {\n          ...this.policy.responseHeaders(),\n        },\n      })\n    }\n\n    response.headers.set('x-local-cache', encodeURIComponent(this.options.cachePath))\n    response.headers.set('x-local-cache-hash', encodeURIComponent(this.entry.integrity))\n    response.headers.set('x-local-cache-key', encodeURIComponent(this.key))\n    response.headers.set('x-local-cache-mode', shouldBuffer ? 'buffer' : 'stream')\n    response.headers.set('x-local-cache-status', status)\n    response.headers.set('x-local-cache-time', new Date(this.entry.metadata.time).toUTCString())\n    return response\n  }\n\n  // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n  async revalidate (request, options) {\n    const revalidateRequest = new Request(request, {\n      headers: this.policy.revalidationHeaders(request),\n    })\n\n    try {\n      // NOTE: be sure to remove the headers property from the\n      // user supplied options, since we have already defined\n      // them on the new request object. if they're still in the\n      // options then those will overwrite the ones from the policy\n      var response = await remote(revalidateRequest, {\n        ...options,\n        headers: undefined,\n      })\n    } catch (err) {\n      // if the network fetch fails, return the stale\n      // cached response unless it has a cache-control\n      // of 'must-revalidate'\n      if (!this.policy.mustRevalidate)\n        return this.respond(request.method, options, 'stale')\n\n      throw err\n    }\n\n    if (this.policy.revalidated(revalidateRequest, response)) {\n      // we got a 304, write a new index to the cache and respond from cache\n      const metadata = getMetadata(request, response, options)\n      // 304 responses do not include headers that are specific to the response data\n      // since they do not include a body, so we copy values for headers that were\n      // in the old cache entry to the new one, if the new metadata does not already\n      // include that header\n      for (const name of KEEP_RESPONSE_HEADERS) {\n        if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(this.entry.metadata.resHeaders, name))\n          metadata.resHeaders[name] = this.entry.metadata.resHeaders[name]\n      }\n\n      try {\n        await cacache.index.insert(options.cachePath, this.key, this.entry.integrity, {\n          size: this.entry.size,\n          metadata,\n        })\n      } catch (err) {\n        // if updating the cache index fails, we ignore it and\n        // respond anyway\n      }\n      return this.respond(request.method, options, 'revalidated')\n    }\n\n    // if we got a modified response, create a new entry based on it\n    const newEntry = new CacheEntry({\n      request,\n      response,\n      options,\n    })\n\n    // respond with the new entry while writing it to the cache\n    return newEntry.store('updated')\n  }\n}\n\nmodule.exports = CacheEntry\n"]},"metadata":{},"sourceType":"script"}