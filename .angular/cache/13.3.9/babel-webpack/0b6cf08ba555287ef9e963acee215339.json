{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  dirname,\n  resolve\n} = require('path');\n\nconst fileURLToPath = require('./file-url-to-path/index.js');\n\nconst fs = require('../fs.js'); // given a path, find the owner of the nearest parent\n\n\nconst find = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path) {\n    // if we have no getuid, permissions are irrelevant on this platform\n    if (!process.getuid) {\n      return {};\n    } // fs methods accept URL objects with a scheme of file: so we need to unwrap\n    // those into an actual path string before we can resolve it\n\n\n    const resolved = path != null && path.href && path.origin ? resolve(fileURLToPath(path)) : resolve(path);\n    let stat;\n\n    try {\n      stat = yield fs.lstat(resolved);\n    } finally {\n      // if we got a stat, return its contents\n      if (stat) {\n        return {\n          uid: stat.uid,\n          gid: stat.gid\n        };\n      } // try the parent directory\n\n\n      if (resolved !== dirname(resolved)) {\n        return find(dirname(resolved));\n      } // no more parents, never got a stat, just return an empty object\n\n\n      return {};\n    }\n  });\n\n  return function find(_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // given a path, uid, and gid update the ownership of the path if necessary\n\n\nconst update = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (path, uid, gid) {\n    // nothing to update, just exit\n    if (uid === undefined && gid === undefined) {\n      return;\n    }\n\n    try {\n      // see if the permissions are already the same, if they are we don't\n      // need to do anything, so return early\n      const stat = yield fs.stat(path);\n\n      if (uid === stat.uid && gid === stat.gid) {\n        return;\n      }\n    } catch (err) {}\n\n    try {\n      yield fs.chown(path, uid, gid);\n    } catch (err) {}\n  });\n\n  return function update(_x2, _x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\n\n\nconst validate = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (path, input) {\n    let uid;\n    let gid;\n\n    if (typeof input === 'string' || typeof input === 'number') {\n      uid = input;\n      gid = input;\n    } else if (input && typeof input === 'object') {\n      uid = input.uid;\n      gid = input.gid;\n    }\n\n    if (uid === 'inherit' || gid === 'inherit') {\n      const owner = yield find(path);\n\n      if (uid === 'inherit') {\n        uid = owner.uid;\n      }\n\n      if (gid === 'inherit') {\n        gid = owner.gid;\n      }\n    }\n\n    return {\n      uid,\n      gid\n    };\n  });\n\n  return function validate(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nmodule.exports = {\n  find,\n  update,\n  validate\n};","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@npmcli/fs/lib/common/owner.js"],"names":["dirname","resolve","require","fileURLToPath","fs","find","path","process","getuid","resolved","href","origin","stat","lstat","uid","gid","update","undefined","err","chown","validate","input","owner","module","exports"],"mappings":"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","sourcesContent":["const { dirname, resolve } = require('path')\n\nconst fileURLToPath = require('./file-url-to-path/index.js')\nconst fs = require('../fs.js')\n\n// given a path, find the owner of the nearest parent\nconst find = async (path) => {\n  // if we have no getuid, permissions are irrelevant on this platform\n  if (!process.getuid) {\n    return {}\n  }\n\n  // fs methods accept URL objects with a scheme of file: so we need to unwrap\n  // those into an actual path string before we can resolve it\n  const resolved = path != null && path.href && path.origin\n    ? resolve(fileURLToPath(path))\n    : resolve(path)\n\n  let stat\n\n  try {\n    stat = await fs.lstat(resolved)\n  } finally {\n    // if we got a stat, return its contents\n    if (stat) {\n      return { uid: stat.uid, gid: stat.gid }\n    }\n\n    // try the parent directory\n    if (resolved !== dirname(resolved)) {\n      return find(dirname(resolved))\n    }\n\n    // no more parents, never got a stat, just return an empty object\n    return {}\n  }\n}\n\n// given a path, uid, and gid update the ownership of the path if necessary\nconst update = async (path, uid, gid) => {\n  // nothing to update, just exit\n  if (uid === undefined && gid === undefined) {\n    return\n  }\n\n  try {\n    // see if the permissions are already the same, if they are we don't\n    // need to do anything, so return early\n    const stat = await fs.stat(path)\n    if (uid === stat.uid && gid === stat.gid) {\n      return\n    }\n  } catch (err) {}\n\n  try {\n    await fs.chown(path, uid, gid)\n  } catch (err) {}\n}\n\n// accepts a `path` and the `owner` property of an options object and normalizes\n// it into an object with numerical `uid` and `gid`\nconst validate = async (path, input) => {\n  let uid\n  let gid\n\n  if (typeof input === 'string' || typeof input === 'number') {\n    uid = input\n    gid = input\n  } else if (input && typeof input === 'object') {\n    uid = input.uid\n    gid = input.gid\n  }\n\n  if (uid === 'inherit' || gid === 'inherit') {\n    const owner = await find(path)\n    if (uid === 'inherit') {\n      uid = owner.uid\n    }\n\n    if (gid === 'inherit') {\n      gid = owner.gid\n    }\n  }\n\n  return { uid, gid }\n}\n\nmodule.exports = {\n  find,\n  update,\n  validate,\n}\n"]},"metadata":{},"sourceType":"script"}