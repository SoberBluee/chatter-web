{"ast":null,"code":"var _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  NotCachedError\n} = require('./errors.js');\n\nconst CacheEntry = require('./entry.js');\n\nconst remote = require('../remote.js'); // do whatever is necessary to get a Response and return it\n\n\nconst cacheFetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (request, options) {\n    // try to find a cached entry that satisfies this request\n    const entry = yield CacheEntry.find(request, options);\n\n    if (!entry) {\n      // no cached result, if the cache mode is 'only-if-cached' that's a failure\n      if (options.cache === 'only-if-cached') throw new NotCachedError(request.url); // otherwise, we make a request, store it and return it\n\n      const response = yield remote(request, options);\n      const entry = new CacheEntry({\n        request,\n        response,\n        options\n      });\n      return entry.store('miss');\n    } // we have a cached response that satisfies this request, however if the cache\n    // mode is 'no-cache' then we send the revalidation request no matter what\n\n\n    if (options.cache === 'no-cache') return entry.revalidate(request, options); // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n    // 'only-if-cached' we can respond with the cached entry. set the status\n    // based on the result of needsRevalidation and respond\n\n    const _needsRevalidation = entry.policy.needsRevalidation(request);\n\n    if (options.cache === 'force-cache' || options.cache === 'only-if-cached' || !_needsRevalidation) return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit'); // if we got here, the cache entry is stale so revalidate it\n\n    return entry.revalidate(request, options);\n  });\n\n  return function cacheFetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\ncacheFetch.invalidate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (request, options) {\n    if (!options.cachePath) return;\n    return CacheEntry.invalidate(request, options);\n  });\n\n  return function (_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = cacheFetch;","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/make-fetch-happen/lib/cache/index.js"],"names":["NotCachedError","require","CacheEntry","remote","cacheFetch","request","options","entry","find","cache","url","response","store","revalidate","_needsRevalidation","policy","needsRevalidation","respond","method","invalidate","cachePath","module","exports"],"mappings":";;AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAqBC,OAAO,CAAC,aAAD,CAAlC;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,cAAD,CAAtB,C,CAEA;;;AACA,MAAMG,UAAU;AAAA,+BAAG,WAAOC,OAAP,EAAgBC,OAAhB,EAA4B;AAC7C;AACA,UAAMC,KAAK,SAASL,UAAU,CAACM,IAAX,CAAgBH,OAAhB,EAAyBC,OAAzB,CAApB;;AACA,QAAI,CAACC,KAAL,EAAY;AACV;AACA,UAAID,OAAO,CAACG,KAAR,KAAkB,gBAAtB,EACE,MAAM,IAAIT,cAAJ,CAAmBK,OAAO,CAACK,GAA3B,CAAN,CAHQ,CAKV;;AACA,YAAMC,QAAQ,SAASR,MAAM,CAACE,OAAD,EAAUC,OAAV,CAA7B;AACA,YAAMC,KAAK,GAAG,IAAIL,UAAJ,CAAe;AAAEG,QAAAA,OAAF;AAAWM,QAAAA,QAAX;AAAqBL,QAAAA;AAArB,OAAf,CAAd;AACA,aAAOC,KAAK,CAACK,KAAN,CAAY,MAAZ,CAAP;AACD,KAZ4C,CAc7C;AACA;;;AACA,QAAIN,OAAO,CAACG,KAAR,KAAkB,UAAtB,EACE,OAAOF,KAAK,CAACM,UAAN,CAAiBR,OAAjB,EAA0BC,OAA1B,CAAP,CAjB2C,CAmB7C;AACA;AACA;;AACA,UAAMQ,kBAAkB,GAAGP,KAAK,CAACQ,MAAN,CAAaC,iBAAb,CAA+BX,OAA/B,CAA3B;;AACA,QAAIC,OAAO,CAACG,KAAR,KAAkB,aAAlB,IACAH,OAAO,CAACG,KAAR,KAAkB,gBADlB,IAEA,CAACK,kBAFL,EAGE,OAAOP,KAAK,CAACU,OAAN,CAAcZ,OAAO,CAACa,MAAtB,EAA8BZ,OAA9B,EAAuCQ,kBAAkB,GAAG,OAAH,GAAa,KAAtE,CAAP,CA1B2C,CA4B7C;;AACA,WAAOP,KAAK,CAACM,UAAN,CAAiBR,OAAjB,EAA0BC,OAA1B,CAAP;AACD,GA9Be;;AAAA,kBAAVF,UAAU;AAAA;AAAA;AAAA,GAAhB;;AAgCAA,UAAU,CAACe,UAAX;AAAA,gCAAwB,WAAOd,OAAP,EAAgBC,OAAhB,EAA4B;AAClD,QAAI,CAACA,OAAO,CAACc,SAAb,EACE;AAEF,WAAOlB,UAAU,CAACiB,UAAX,CAAsBd,OAAtB,EAA+BC,OAA/B,CAAP;AACD,GALD;;AAAA;AAAA;AAAA;AAAA;;AAOAe,MAAM,CAACC,OAAP,GAAiBlB,UAAjB","sourcesContent":["const { NotCachedError } = require('./errors.js')\nconst CacheEntry = require('./entry.js')\nconst remote = require('../remote.js')\n\n// do whatever is necessary to get a Response and return it\nconst cacheFetch = async (request, options) => {\n  // try to find a cached entry that satisfies this request\n  const entry = await CacheEntry.find(request, options)\n  if (!entry) {\n    // no cached result, if the cache mode is 'only-if-cached' that's a failure\n    if (options.cache === 'only-if-cached')\n      throw new NotCachedError(request.url)\n\n    // otherwise, we make a request, store it and return it\n    const response = await remote(request, options)\n    const entry = new CacheEntry({ request, response, options })\n    return entry.store('miss')\n  }\n\n  // we have a cached response that satisfies this request, however if the cache\n  // mode is 'no-cache' then we send the revalidation request no matter what\n  if (options.cache === 'no-cache')\n    return entry.revalidate(request, options)\n\n  // if the cached entry is not stale, or if the cache mode is 'force-cache' or\n  // 'only-if-cached' we can respond with the cached entry. set the status\n  // based on the result of needsRevalidation and respond\n  const _needsRevalidation = entry.policy.needsRevalidation(request)\n  if (options.cache === 'force-cache' ||\n      options.cache === 'only-if-cached' ||\n      !_needsRevalidation)\n    return entry.respond(request.method, options, _needsRevalidation ? 'stale' : 'hit')\n\n  // if we got here, the cache entry is stale so revalidate it\n  return entry.revalidate(request, options)\n}\n\ncacheFetch.invalidate = async (request, options) => {\n  if (!options.cachePath)\n    return\n\n  return CacheEntry.invalidate(request, options)\n}\n\nmodule.exports = cacheFetch\n"]},"metadata":{},"sourceType":"script"}