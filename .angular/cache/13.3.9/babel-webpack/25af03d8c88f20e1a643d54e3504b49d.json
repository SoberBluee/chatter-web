{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst fetch = require('make-fetch-happen');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\n\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing\n\n    log.verbose('install', 'input version string %j', release.version);\n\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    } // flatten version into String\n\n\n    log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n    const devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n\n        throw err;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n\n      log.verbose('install', 'version is good');\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n\n\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n\n          if (created) {\n            log.verbose('created nodedir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n\n          throw err;\n        } // now download the node tarball\n\n\n        const tarPath = gyp.opts.tarball;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n\n        function isValid(path) {\n          const isValid = valid(path);\n\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n\n          return isValid;\n        } // download the tarball and extract!\n\n\n        if (tarPath) {\n          yield tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            cwd: devDir\n          });\n        } else {\n          try {\n            const res = yield download(gyp, release.tarballUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n            }\n\n            yield streamPipeline(res.body, // content checksum\n            new ShaSum((_, checksum) => {\n              const filename = path.basename(release.tarballUrl).trim();\n              contentShasums[filename] = checksum;\n              log.verbose('content checksum', filename, checksum);\n            }), tar.extract({\n              strip: 1,\n              cwd: devDir,\n              filter: isValid\n            }));\n          } catch (err) {\n            // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n            }\n\n            throw err;\n          }\n        } // invoked after the tarball has finished being extracted\n\n\n        if (extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball');\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        const installVersionPath = path.resolve(devDir, 'installVersion');\n        yield Promise.all([// need to download node.lib\n        ...(win ? downloadNodeLib() : []), // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'), // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])]);\n        log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n        for (const k in contentShasums) {\n          log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n          if (contentShasums[k] !== expectShasums[k]) {\n            throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n          }\n        }\n\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n\n              if (items.length !== 2) {\n                return;\n              } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function downloadNodeLib() {\n          log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n          const archs = ['ia32', 'x64', 'arm64'];\n          return archs.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (arch) {\n              const dir = path.resolve(devDir, arch);\n              const targetLibPath = path.resolve(dir, release.name + '.lib');\n              const {\n                libUrl,\n                libPath\n              } = release[arch];\n              const name = `${arch} ${release.name}.lib`;\n              log.verbose(name, 'dir', dir);\n              log.verbose(name, 'url', libUrl);\n              yield fs.promises.mkdir(dir, {\n                recursive: true\n              });\n              log.verbose('streaming', name, 'to:', targetLibPath);\n              const res = yield download(gyp, libUrl);\n\n              if (res.status === 403 || res.status === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n\n                return;\n              } else if (res.status !== 200) {\n                throw new Error(`${res.status} status code downloading ${name}`);\n              }\n\n              return streamPipeline(res.body, new ShaSum((_, checksum) => {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              }), fs.createWriteStream(targetLibPath));\n            });\n\n            return function (_x9) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        } // downloadNodeLib()\n\n      });\n      return _go.apply(this, arguments);\n    }\n\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n\n    function rollback(_x7) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n\n\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n\n    function eaccesFallback(_x8) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\n\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n\n    callback(null, chunk);\n  }\n\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n\n    callback();\n  }\n\n}\n\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\n\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\n\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\n\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\n\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/node-gyp/lib/install.js"],"names":["fs","require","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","shasumsUrl","line","text","split","items","length","name","replace","archs","map","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","extname","commands","remove","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"]},"metadata":{},"sourceType":"script"}