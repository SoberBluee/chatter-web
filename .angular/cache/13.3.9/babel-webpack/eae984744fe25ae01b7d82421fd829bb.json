{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst childProcess = require('child_process');\n\nconst {\n  isLinux,\n  getReport\n} = require('./process');\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise(resolve => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, {\n        encoding: 'utf8'\n      });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n\n  return commandOut;\n};\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\n\n\nconst GLIBC = 'glibc';\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\n\nconst MUSL = 'musl';\n\nconst isFileMusl = f => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n\n  return null;\n};\n\nconst familyFromCommand = out => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n\n  return null;\n};\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\n\n\nconst family = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    let family = null;\n\n    if (isLinux()) {\n      family = familyFromReport();\n\n      if (!family) {\n        const out = yield safeCommand();\n        family = familyFromCommand(out);\n      }\n    }\n\n    return family;\n  });\n\n  return function family() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\n\n\nconst familySync = () => {\n  let family = null;\n\n  if (isLinux()) {\n    family = familyFromReport();\n\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n\n  return family;\n};\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\n\n\nconst isNonGlibcLinux = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* () {\n    return isLinux() && (yield family()) !== GLIBC;\n  });\n\n  return function isNonGlibcLinux() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\n\n\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromReport = () => {\n  const report = getReport();\n\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n\n  return null;\n};\n\nconst versionSuffix = s => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = out => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n\n  return null;\n};\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\n\n\nconst version = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* () {\n    let version = null;\n\n    if (isLinux()) {\n      version = versionFromReport();\n\n      if (!version) {\n        const out = yield safeCommand();\n        version = versionFromCommand(out);\n      }\n    }\n\n    return version;\n  });\n\n  return function version() {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\n\n\nconst versionSync = () => {\n  let version = null;\n\n  if (isLinux()) {\n    version = versionFromReport();\n\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};","map":{"version":3,"sources":["/Users/ethandonovan/Documents/GitHub/chatter-web/node_modules/detect-libc/lib/detect-libc.js"],"names":["childProcess","require","isLinux","getReport","command","commandOut","safeCommand","Promise","resolve","exec","err","out","safeCommandSync","execSync","encoding","_err","GLIBC","MUSL","isFileMusl","f","includes","familyFromReport","report","header","glibcVersionRuntime","Array","isArray","sharedObjects","some","familyFromCommand","getconf","ldd1","split","family","familySync","isNonGlibcLinux","isNonGlibcLinuxSync","versionFromReport","versionSuffix","s","trim","versionFromCommand","ldd2","version","versionSync","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromReport();\n    if (!family) {\n      const out = await safeCommand();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromReport();\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromReport();\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromReport();\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n"]},"metadata":{},"sourceType":"script"}